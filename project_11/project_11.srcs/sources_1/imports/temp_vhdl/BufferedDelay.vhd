library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use IEEE.MATH_REAL.ALL;

LIBRARY work;
USE work.ALL;
USE work.Components.ALL;

entity BufferedDelay is
	generic(
        WL: integer:= 8;    -- Word Length
        BL: integer:= 64);  -- Buffer Length
	port(
        rst:  in  std_logic;
        clk:  in  std_logic;
        enable: in std_logic;
        delay_mem_counter: in std_logic_vector(bits(BL-1-2) -1 downto 0);
        Din:  in  std_logic_vector(WL -1 downto 0);
        Dout: out std_logic_vector(WL -1 downto 0)
     );
end BufferedDelay;

architecture arch of BufferedDelay is

    -- attribute KEEP_HIERARCHY : string;
    -- attribute KEEP_HIERARCHY of BufferedDelay : entity is "yes";

   -- At and under this limit, the delay is generated using registers.
   -- Over this limit, the delay is generated using memories.
   constant LimitReg: integer:= 34;

   signal first_buffer_out : std_logic_vector(WL -1 downto 0);
   signal mem_buffer_out   : std_logic_vector(WL -1 downto 0);

begin

   NoDelay: if BL = 0 generate
         Dout <= Din;
   end generate;

   -- At and under LimitReg, the delay is generated by using registers.
   GenReg: if (BL <= LimitReg) AND (BL > 0) generate

      RegBuffer: entity work.DelayReg
         generic map(
            WL => WL,
            BL => BL)
         port map(
            clk  => clk,
            clearOnHigh => '0',
            enable => enable,
            Din  => Din,
            Dout => Dout);

   end generate;

   -- Over LimitReg, the delay is generated using memories.
   GenMem: if BL > LimitReg generate

    First_buffer: entity work.DelayReg
        generic map(
            WL => WL,
            BL => 1)
        port map(
            clk  => clk,
            clearOnHigh => '0',
            enable => enable,
            Din  => Din,
            Dout => first_buffer_out);

    MemBuffer: entity work.DelayMem
        generic map(
            WL => WL,
            BL => BL-2)
        port map(
            rst  => rst,
            clk  => clk,
            enable => enable,
            delay_mem_counter => delay_mem_counter,
            Din  => first_buffer_out,
            Dout => mem_buffer_out);

    Last_buffer: entity work.DelayReg
        generic map(
            WL => WL,
            BL => 1)
        port map(
            clk  => clk,
            clearOnHigh => '0',
            enable => enable,
            Din  => mem_buffer_out,
            Dout => Dout);

   end generate;

end arch;
