--Delay.

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use IEEE.MATH_REAL.ALL;

LIBRARY work;
USE work.ALL;
USE work.Components.ALL;

entity Delay is
	generic(	
        WL: integer:= 8;    -- Word Length
        BL: integer:= 64);  -- Buffer Length
	port(
        rst:  in  std_logic;
        clk:  in  std_logic;
        enable: in std_logic;
        delay_mem_counter: in std_logic_vector(bits(BL-1) -1 downto 0);
        Din:  in  std_logic_vector(WL -1 downto 0);
        Dout: out std_logic_vector(WL -1 downto 0)
     );
end Delay;

architecture arch of Delay is

    -- attribute KEEP_HIERARCHY : string;
    -- attribute KEEP_HIERARCHY of Delay : entity is "yes";

   -- At and under this limit, the delay is generated using registers. 
   -- Over this limit, the delay is generated using memories.
   constant LimitReg: integer:= 34;  -- TODO: Those DelayMem entities do NOT WORK PROPERLY!

begin 

   NoDelay: if BL = 0 generate   
         Dout <= Din;
   end generate;
   
   -- At and under LimitReg, the delay is generated by using registers.
   GenReg: if (BL <= LimitReg) AND (BL > 0) generate
   
      RegBuffer: entity work.DelayReg
         generic map(	
            WL => WL,   
            BL => BL)		            
         port map(
            clk  => clk,
            clearOnHigh => '0',
            enable => enable,
            Din  => Din, 
            Dout => Dout);
   
   end generate;
   
   -- Over LimitReg, the delay is generated using memories.
   GenMem: if BL > LimitReg generate
   
      MemBuffer: entity work.DelayMem
         generic map(   
            WL => WL,   
            BL => BL)                  
         port map(
            rst  => rst,
            clk  => clk,
            enable => enable,
            delay_mem_counter => delay_mem_counter,
            Din  => Din, 
            Dout => Dout);
      
   end generate;
      
end arch;
